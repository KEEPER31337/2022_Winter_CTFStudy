#   for ( i = 0; (unsigned __int64)i < 0x1C; ++i )
#   {
#     if ( ((unsigned __int8)(16 * *(_BYTE *)(a1 + i)) | ((int)*(unsigned __int8 *)(a1 + i) >> 4)) != byte_140003000[i] )
#       return 0;

# .data:0000000140003000 byte_140003000  db 24h, 27h, 13h, 2 dup(0C6h), 13h, 16h, 0E6h, 47h, 0F5h
# .data:0000000140003000                                         ; DATA XREF: sub_140001000+50↑o
# .data:0000000140003000                 db 26h, 96h, 47h, 0F5h, 46h, 27h, 13h, 2 dup(26h), 0C6h
# .data:0000000140003000                 db 56h, 0F5h, 2 dup(0C3h), 0F5h, 2 dup(0E3h), 5 dup(0)
# num1 dup(num2) == num2를 num1의 수만큼 반복해서 배열에 들어감을 뜻한다.
# == 0x24,0x27,0x13,0xC6,0xC6,0x13,0x16,0xE6,0x47,0xF5,0x26,0x96,0x47,0xF5,0x46,0x27,0x13,0x26,0x26,0xC6,0x56,0xF5,0xC3,0xC3,0xF5,0xE3,0xE3,0x0,0x0,0x0,0x0,0x0

temp = [0x24,0x27,0x13,0xC6,0xC6,0x13,0x16,0xE6,0x47,0xF5,0x26,0x96,0x47,0xF5,0x46,0x27,0x13,0x26,0x26,0xC6,0x56,0xF5,0xC3,0xC3,0xF5,0xE3,0xE3,0x0,0x0,0x0,0x0,0x0]

for i in range(0x1C):
    print(chr(((temp[i]<<4)|(temp[i]>>4))&0b11111111),end="")
    
# if ( ((16 * num[i]) | (int(num[i]) >> 4)) != temp[i] )

# 16 * i = i << 4
# 11 0000

# i << 4 | i >> 4 

# 0000 0000
# 앞의 4비트와 뒤의 4비트가 변경되는것을 볼수있다.
