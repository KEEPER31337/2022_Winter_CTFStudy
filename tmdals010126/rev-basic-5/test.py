#   for ( i = 0; (unsigned __int64)i < 0x18; ++i )
#   {
#     if ( *(unsigned __int8 *)(a1 + i + 1) + *(unsigned __int8 *)(a1 + i) != byte_140003000[i] )
#       return 0;

# .data:0000000140003000 byte_140003000  db 0ADh, 0D8h, 2 dup(0CBh), 9Dh, 97h, 0CBh, 0C4h, 92h
# .data:0000000140003000                                         ; DATA XREF: sub_140001000+48↑o
# .data:0000000140003000                 db 0A1h, 0D2h, 0D7h, 0D2h, 0D6h, 0A8h, 0A5h, 0DCh, 0C7h
# .data:0000000140003000                 db 0ADh, 0A3h, 0A1h, 98h, 4Ch, 9 dup(0)
# num1 dup(num2) == num2를 num1의 수만큼 반복해서 배열에 들어감을 뜻한다.
# == 0xAD,0xD8,0xCB,0xCB,0x9D,0x97,0xCB,0xC4,0x92,0xA1,0xD2,0xD7,0xD2,0xD6,0xA8,0xA5,0xDC,0xC7,0xAD,0xA3,0xA1,0x98,0x4C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0

temp = [0xAD,0xD8,0xCB,0xCB,0x9D,0x97,0xCB,0xC4,0x92,0xA1,0xD2,0xD7,0xD2,0xD6,0xA8,0xA5,0xDC,0xC7,0xAD,0xA3,0xA1,0x98,0x4C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0]


asdf = 0
result = []
for i in range(0x18,-1,-1):
    result.append(chr(temp[i]-asdf))
    asdf = temp[i]-asdf
for i in reversed(result):
    print(i,end="")
    

# if ( a[i+1] + a[i] == temp[i] )
# temp[i]
